//
// Copyright (c) 2012, J2 Innovations
// Licensed under the Academic Free License version 3.0
//
// History:
//   04 Oct 2012  Mike Jarmy  Creation
//
package nhaystack.server.storehouse;

import java.util.*;

import javax.baja.control.*;
import javax.baja.control.ext.*;
import javax.baja.driver.*;
import javax.baja.driver.point.*;
import javax.baja.history.*;
import javax.baja.history.ext.*;
import javax.baja.naming.*;
import javax.baja.status.*;
import javax.baja.sys.*;
import javax.baja.util.*;

import haystack.*;
import nhaystack.*;
import nhaystack.collection.*;
import nhaystack.server.*;

/**
  * ConfigStorehouse manages access to the BComponentSpace
  */
public class ConfigStorehouse extends Storehouse
{
    public ConfigStorehouse(NHServer server)
    {
        super(server);
    }

    /**
      * Create the haystack representation of a BComponent.
      *
      * The haystack representation is a combination of the 
      * autogenerated tags, and those tags specified
      * in the explicit haystack annotation (if any).
      *
      * This method never returns null.
      */
    public HDict createComponentTags(BComponent comp)
    {
        HDictBuilder hdb = new HDictBuilder();

        // add existing tags
        BHDict btags = BHDict.findTagAnnotation(comp);
        HDict tags = (btags == null) ?  HDict.EMPTY : btags.getDict();
        hdb.add(tags);

        // add id
        hdb.add("id", NHRef.make(comp).getHRef());
        
        // add misc other tags
        String dis = comp.getDisplayName(null);
        if (dis != null) hdb.add("dis", dis);
        hdb.add("axType", comp.getType().toString());
        hdb.add("axSlotPath", comp.getSlotPath().toString());

        // points get special treatment
        if (comp instanceof BControlPoint)
        {
            BControlPoint point = (BControlPoint) comp;

            // ensure there is a point marker tag
            hdb.add("point");

            // check if this point has a history
            BHistoryConfig cfg = server.getHistoryStorehouse().lookupHistoryFromPoint(point);
            if (cfg != null)
            {
                hdb.add("his");

                if (service.getShowLinkedHistories())
                    hdb.add("axHistoryRef", NHRef.make(cfg).getHRef());

                // tz
                if (!tags.has("tz"))
                {
                    HTimeZone tz = makeTimeZone(cfg.getTimeZone());
                    hdb.add("tz", tz.name);
                }

                // hisInterpolate 
                if (!tags.has("hisInterpolate"))
                {
                    BHistoryExt historyExt = lookupHistoryExt(point);
                    if (historyExt != null && (historyExt instanceof BCovHistoryExt))
                        hdb.add("hisInterpolate", "cov");
                }
            }

            // point kind tags
            int pointKind = getControlPointKind(point);
            BFacets facets = (BFacets) point.get("facets");
            addPointKindTags(pointKind, facets, tags, hdb);

            // curVal, curStatus
            switch(pointKind)
            {
                case NUMERIC_KIND:
                    BNumericPoint np = (BNumericPoint) point;
                    hdb.add("curVal",    HNum.make(np.getNumeric()));
                    hdb.add("curStatus", makeStatusString(point.getStatus()));
                    break;

                case BOOLEAN_KIND:
                    BBooleanPoint bp = (BBooleanPoint) point;
                    hdb.add("curVal",    HBool.make(bp.getBoolean()));
                    hdb.add("curStatus", makeStatusString(point.getStatus()));
                    break;

                case ENUM_KIND:
                    BEnumPoint ep = (BEnumPoint) point;
                    hdb.add("curVal",    HStr.make(ep.getEnum().toString()));
                    hdb.add("curStatus", makeStatusString(point.getStatus()));
                    break;

                case STRING_KIND:
                    BStringPoint sp = (BStringPoint) point;
                    hdb.add("curVal",    HStr.make(sp.getOut().getValue().toString()));
                    hdb.add("curStatus", makeStatusString(point.getStatus()));
                    break;
            }
        }

        // done
        return hdb.toDict();
    }

    /**
      * Return whether the given component-space component
      * ought to be turned into a record.
      */
    public boolean isVisibleComponent(BComponent comp)
    {
        // Return true for components that have been 
        // annotated with a BHDict instance.
        if (BHDict.findTagAnnotation(comp) != null)
            return true;

        // Return true for BControlPoints.
        if (comp instanceof BControlPoint)
            return true;

        // nope
        return false;
    }

    /**
      * Try to find the point that goes with a history,
      * or return null.
      */
    public BControlPoint lookupPointFromHistory(BHistoryConfig cfg)
    {
        // local history
        if (cfg.getId().getDeviceName().equals(Sys.getStation().getStationName()))
        {
            BOrd[] ords = cfg.getSource().toArray();
            if (ords.length != 1) new IllegalStateException(
                "invalid Source: " + cfg.getSource());

            BComponent source = (BComponent) ords[0].resolve(service, null).get();

            // The source is not always a BHistoryExt.  E.g. for 
            // LogHistory its the LogHistoryService.
            if (source instanceof BHistoryExt)
            {
                if (source.getParent() instanceof BControlPoint)
                    return (BControlPoint) source.getParent();
            }

            return null;
        }
        // look for imported point that goes with history (if any)
        else
        {
            return lookupRemotePoint(cfg);
        }
    }

    public HGrid onNav(String navId)
    {
        // child of ComponentSpace root
        if (navId.equals(Sys.getStation().getStationName() + ":c"))
        {
            BComponent root = (BComponent) BOrd.make("slot:/").resolve(service, null).get();
            return HGridBuilder.dictsToGrid(new HDict[] { makeNavResult(root) });
        }
        // ComponentSpace component
        else if (navId.startsWith(Sys.getStation().getStationName() + ":c."))
        {
            NHRef nid = NHRef.make(HRef.make(navId));
            BComponent comp = service.getComponentSpace().findByHandle(nid.getHandle());
            BComponent kids[] = comp.getChildComponents();

            Array dicts = new Array(HDict.class);
            for (int i = 0; i < kids.length; i++)
                dicts.add(makeNavResult(kids[i]));
            return HGridBuilder.dictsToGrid((HDict[]) dicts.trim());
        }
        else throw new BajaRuntimeException("Cannot lookup nav for " + navId);
    }

    /**
      * Return the BHistoryExt for the point, if there is one.
      * Returns null if the BHistoryExt has never been enabled.
      */
    public BHistoryExt lookupHistoryExt(BControlPoint point)
    {
        Cursor cursor = point.getProperties();
        if (cursor.next(BHistoryExt.class))
        {
            BHistoryExt ext = (BHistoryExt) cursor.get();

            // Return null if the extension has never been enabled.
            BHistoryConfig config = ext.getHistoryConfig();
            if (service.getHistoryDb().getHistory(config.getId()) == null)
                return null;

            return ext;
        }

        return null;
    }

    /**
      * Iterator through all the points
      */
    public Iterator makeIterator()
    {
        return new PointStorehouseIterator();
    }

////////////////////////////////////////////////////////////////
// private
////////////////////////////////////////////////////////////////

    /**
      * Find the imported point that goes with an imported history, 
      * or return null.  
      * <p>
      * This method is rather inefficient.  When operating on histories
      * in bulk, e.g. inside NHServer.iterator(), a different approach 
      * should be used.
      */
    private BControlPoint lookupRemotePoint(BHistoryConfig cfg)
    {
        // cannot be local history
        if (cfg.getId().getDeviceName().equals(Sys.getStation().getStationName()))
            throw new IllegalStateException();

        RemotePoint remotePoint = RemotePoint.fromHistoryConfig(cfg);
        if (remotePoint == null) return null;

        // look up the station
        BDeviceNetwork network = service.getNiagaraNetwork();
        BDevice station = (BDevice) network.get(remotePoint.getStationName());
        if (station == null) return null;

        // look up the points
        BPointDeviceExt pointDevExt = (BPointDeviceExt) station.get("points");
        BControlPoint[] points = pointDevExt.getPoints(); // fetches from sub-folders too

        // find a point with matching slot path
        for (int i = 0; i < points.length; i++)
        {
            BControlPoint point = points[i];

            // Check for a NiagaraProxyExt
            BAbstractProxyExt proxyExt = point.getProxyExt();
            if (!proxyExt.getType().is(RemotePoint.NIAGARA_PROXY_EXT)) continue;

            // "pointId" seems to always contain the slotPath on 
            // the remote host.
            String slotPath = proxyExt.get("pointId").toString();

            // found it!
            if (slotPath.equals(remotePoint.getSlotPath().toString()))
                return point;
        }

        // no such point
        return null;
    }

    private static int getControlPointKind(BControlPoint point)
    {
        if      (point instanceof BNumericPoint) return NUMERIC_KIND;
        else if (point instanceof BBooleanPoint) return BOOLEAN_KIND;
        else if (point instanceof BEnumPoint)    return ENUM_KIND;
        else if (point instanceof BStringPoint)  return STRING_KIND;

        else return UNKNOWN_KIND;
    }

    private static String makeStatusString(BStatus status)
    {
        if (status.isOk())
            return "ok";

        // TODO define proper ordering for these -- look at oBIX
        if (status.isDisabled())     return "disabled";
        if (status.isFault())        return "fault";
        if (status.isDown())         return "down";
        if (status.isAlarm())        return "alarm";
        if (status.isStale())        return "stale";
        if (status.isOverridden())   return "overridden";
        if (status.isNull())         return "null";
        if (status.isUnackedAlarm()) return "unackedAlarm";

        throw new IllegalStateException();
    }

    private HDict makeNavResult(BComponent comp)
    {
        HDictBuilder hdb = new HDictBuilder();

        // add a navId, but only if this component is not a leaf
        if (comp.getChildComponents().length > 0)
            hdb.add("navId", NHRef.make(comp).getHRef().val);

        if (isVisibleComponent(comp))
        {
            hdb.add(createComponentTags(comp));
        }
        else
        {
            String dis = comp.getDisplayName(null);
            if (dis != null) hdb.add("dis", dis);
            hdb.add("axType", comp.getType().toString());
            hdb.add("axSlotPath", comp.getSlotPath().toString());
        }

        return hdb.toDict();
    }

////////////////////////////////////////////////////////////////
// PointStorehouseIterator
////////////////////////////////////////////////////////////////

    /**
      * PointStorehouseIterator
      */
    private class PointStorehouseIterator implements Iterator
    {
        private PointStorehouseIterator()
        {
            iterator = new ComponentTreeIterator(
                (BComponent) BOrd.make("slot:/").resolve(service, null).get());

            findNext();
        }

        public boolean hasNext() { return nextDict != null; }

        public void remove() { throw new UnsupportedOperationException(); }

        public Object next()
        {
            if (nextDict == null) throw new IllegalStateException();

            HDict dict = nextDict;
            findNext();
            return dict;
        }

        private void findNext()
        {
            nextDict = null;
            while (iterator.hasNext())
            {
                BComponent comp = (BComponent) iterator.next();

                if (isVisibleComponent(comp))
                {
                    nextDict = createComponentTags(comp);
                    break;
                }
            }
        }

        private final ComponentTreeIterator iterator;
        private HDict nextDict;
    }
}

