//
// Copyright (c) 2012, J2 Innovations
// Licensed under the Academic Free License version 3.0
//
// History:
//   04 Oct 2012  Mike Jarmy  Creation
//
package nhaystack.server.storehouse;

import java.util.*;

import javax.baja.control.*;
import javax.baja.history.*;
import javax.baja.history.ext.*;
import javax.baja.log.*;
import javax.baja.sys.*;
import javax.baja.util.*;

import org.projecthaystack.*;
import nhaystack.*;
import nhaystack.collection.*;
import nhaystack.server.*;

/**
  * HistoryStorehouse manages access to the BHistoryDatabase
  */
public class HistoryStorehouse extends Storehouse
{
    public HistoryStorehouse(NHServer server)
    {
        super(server);
    }

    /**
      * Try to find either a local or imported history for the point
      */
    public BHistoryConfig lookupHistoryFromPoint(BControlPoint point)
    {
        // local history
        BHistoryExt historyExt = lookupHistoryExt(point);
        if (historyExt != null) return historyExt.getHistoryConfig();

        // look for history that goes with a proxied point (if any)
        if (point.getProxyExt().getType().is(RemotePoint.NIAGARA_PROXY_EXT)) 
            return lookupRemoteHistory(point);
        else 
            return null;
    }

    /**
      * Iterate through all the histories.
      */
    public Iterator makeIterator()
    {
        return new HIterator();
    }

    /**
      * Create the haystack representation of a BHistoryConfig.
      *
      * The haystack representation is a combination of the 
      * autogenerated tags, and those tags specified
      * in the explicit haystack annotation (if any).
      *
      * This method never returns null.
      */
    public HDict createHistoryTags(BHistoryConfig cfg)
    {
        HDictBuilder hdb = new HDictBuilder();

        // add existing tags
        HDict tags = BHDict.findTagAnnotation(cfg);
        if (tags == null) 
            tags = HDict.EMPTY;
        hdb.add(tags);

        // add dis
        String dis = cfg.getId().toString();
        if (dis.startsWith("/")) dis = dis.substring(1);
        dis = TextUtil.replace(dis, "/", "_");
        hdb.add("dis", dis);
        hdb.add("navName", dis);

        // add id
        HRef ref = server.makeComponentRef(cfg).getHRef();
        hdb.add("id", HRef.make(ref.val, dis));

        // add misc other tags
        hdb.add("axType", cfg.getType().toString());
        hdb.add("axHistoryId", cfg.getId().toString());

        hdb.add("point");
        hdb.add("his");

        // time zone
        if (!tags.has("tz"))
        {
            HTimeZone tz = server.makeTimeZone(cfg.getTimeZone());
            if (tz != null) hdb.add("tz", tz.name);
        }

        // point kind tags
        Type recType = cfg.getRecordType().getResolvedType();
        if (recType.is(BTrendRecord.TYPE))
        {
            int pointKind = getTrendRecordKind(recType);
            BFacets facets = (BFacets) cfg.get("valueFacets");
            addPointKindTags(pointKind, facets, tags, hdb);
        }

        // check if this history has a point
        ComponentStorehouse cs = server.getComponentStorehouse();
        BControlPoint point = cs.lookupPointFromHistory(cfg);
        if (point != null)
        {
            // add point ref
            hdb.add("axPointRef", server.makeComponentRef(point).getHRef());

            // hisInterpolate 
            if (!tags.has("hisInterpolate"))
            {
                BHistoryExt historyExt = lookupHistoryExt(point);
                if (historyExt != null && (historyExt instanceof BCovHistoryExt))
                    hdb.add("hisInterpolate", "cov");
            }
        }

        // add custom tags
        hdb.add(server.createCustomTags(cfg));

        // done
        return hdb.toDict();
    }

    /**
      * Return whether this history is visible to the outside world.
      */
    public boolean isVisibleHistory(BHistoryConfig cfg)
    {
        // annotated 
        HDict dict = BHDict.findTagAnnotation(cfg);
        if (dict != null && !dict.isEmpty())
            return true;

        // show linked
        if (service.getShowLinkedHistories())
            return true;

        // make sure the history is not linked
        ComponentStorehouse cs = server.getComponentStorehouse();
        if (cs.lookupPointFromHistory(cfg) == null)
            return true;

        return false;
    }

////////////////////////////////////////////////////////////////
// private
////////////////////////////////////////////////////////////////

    /**
      * Find the imported history that goes with an imported point, 
      * or return null.  
      */
    private BHistoryConfig lookupRemoteHistory(BControlPoint point)
    {
        RemotePoint remotePoint = RemotePoint.fromControlPoint(point);
        if (remotePoint == null) return null;

        return server.getCache().getHistoryConfig(remotePoint);
    }

    private static int getTrendRecordKind(Type trendRecType)
    {
        if      (trendRecType.is(BNumericTrendRecord.TYPE)) return NUMERIC_KIND;
        else if (trendRecType.is(BBooleanTrendRecord.TYPE)) return BOOLEAN_KIND;
        else if (trendRecType.is(BEnumTrendRecord.TYPE))    return ENUM_KIND;
        else if (trendRecType.is(BStringTrendRecord.TYPE))  return STRING_KIND;

        else return UNKNOWN_KIND;
    }

////////////////////////////////////////////////////////////////
// HIterator
////////////////////////////////////////////////////////////////

    class HIterator implements Iterator
    {
        HIterator()
        {
            this.iterator = new HistoryDbIterator(service.getHistoryDb());
            findNext();
        }

        public boolean hasNext() 
        { 
            return nextDict != null; 
        }

        public void remove() { throw new UnsupportedOperationException(); }

        public Object next()
        {
            if (nextDict == null) throw new IllegalStateException();

            HDict dict = nextDict;
            findNext();
            return dict;
        }

        private void findNext()
        {
            nextDict = null;
            while (iterator.hasNext())
            {
                BHistoryConfig cfg = (BHistoryConfig) iterator.next();

                if (isVisibleHistory(cfg))
                {
                    nextDict = createHistoryTags(cfg);
                    break;
                }
            }
        }

        private final HistoryDbIterator iterator;

        private HDict nextDict;
    }

////////////////////////////////////////////////////////////////
// Attributes 
////////////////////////////////////////////////////////////////

    private static final Log LOG = Log.getLog("nhaystack");
}

